from django.contrib.auth.models import AbstractUser
from django.db import models
from django.core.validators import RegexValidator, MinValueValidator
from decimal import Decimal
from django.utils.text import slugify
from cloudinary.models import CloudinaryField

class User(AbstractUser):
    """ 
    custom user model that extends django AbstractUser
    supports multiple roles
    """
    # unique email constraint
    email = models.EmailField(unique=True,blank=False)
    
    ROLE_CHOICES = [
        ('SELLER','Seller'),
        ('CONSUMER', 'Consumer'), 
        ('ADMIN', 'Admin'),
    ]
    
    # define the core role-based system
    role = models.CharField(
        max_length=10,
        choices=ROLE_CHOICES,
        default='CONSUMER',
        help_text="user role to determine access permissions"
    )
    
    # contact and address information
    phone_number = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        validators=[RegexValidator(
            regex=r'^\+?1?\d{9,15}$',
            message="Phone number must be entered in format: '+999999999'. Up to 15 digits allowed."
        )]
    )
    
    address = models.TextField(
        blank=True,
        null=True,
        help_text="Full address for business/shipping purposes"
    )
    
    # seller fields
    store_name = models.CharField(
        max_length=200,
        blank=True,
        null=True,
        help_text="store name to identify the store"
    )
    
    # profile info
    profile_picture = CloudinaryField(
        'image',
        folder='ecommerce/user_profiles/', 
        blank=True, 
        null=True,
        help_text="User profile picture"
    )
    
    # account status tracking for security
    is_email_verified = models.BooleanField(
        default=False,
        help_text="Email verification status"
    )
    
    # automatic timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table='users'
        verbose_name='User'
        verbose_name_plural='Users'
    
    def __str__(self):
        """String representation shows username and role"""
        return f"{self.username} ({self.get_role_display()})"
    
     # Convenience properties to check user roles without string comparison
    @property
    def is_seller(self):
        """Convenience method to check if user is a seller"""
        return self.role == 'SELLER'
    
    @property 
    def is_consumer(self):
        """Convenience method to check if user is a consumer"""
        return self.role == 'CONSUMER'
        
    @property
    def is_admin_user(self):
        """Convenience method to check if user is admin (avoid conflict with is_admin)"""
        return self.role == 'ADMIN'

class Category(models.Model):
    """
    product categories with hierarchichal structure
    supports nested categories for parent child relationships
    eg: electronics > phones > smartphones
    """
    
    # category name
    name = models.CharField(
        max_length=100,
        unique=True,
        help_text="unique category name"
    )
    # detailed description for SEO
    description = models.TextField(
        blank=True,
        null=True,
        help_text="detailed category description"
    )
    # autogenerated url friendly version of name(slug)
    slug = models.SlugField(
        max_length=100,
        unique=True,
        help_text="URL-friendly version of category name"
    )
    # self referencing foreign key for hierachichal structure
    parent_category = models.ForeignKey(
        'self',  #refrences to same model
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name='subcategories',
        help_text="Parent category for hierarchical organization"
    )
    # category status management
    is_active = models.BooleanField(
        default=True,
        help_text="Whether category is active and visible"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'categories'
        verbose_name = 'Category'
        verbose_name_plural = 'Categories'
        ordering = ['name']
    
    def save(self, *args, **kwargs):
        """Auto-generate slug from name if empty, ensure uniqueness"""
        if not self.slug:
            base_slug = slugify(self.name)
            slug = base_slug
            counter = 1
            
            # Ensure slug is unique
            while Category.objects.filter(slug=slug).exists():
                slug = f"{base_slug}-{counter}"
                counter += 1
                
            self.slug = slug
            
        super().save(*args, **kwargs)
    
    def __str__(self):
        """String representation shows full category path"""
        if self.parent_category:
            return f"{self.parent_category.name} > {self.name}"
        return self.name
    
    def get_full_path(self):
        """Returns full category path as list for breadcrumbs"""
        path = [self.name]
        parent = self.parent_category
        while parent:
            path.insert(0, parent.name)
            parent = parent.parent_category
        return path

class Product(models.Model):
    """
    product model with all product information
    each product has one seller and category
    tracks inventory and sales for analytics
    """
    # basic product information
    name = models.CharField(
        max_length=200,
        help_text="Product name/title"
    )
    
    description = models.TextField(
        blank=True,
        null=True,
        help_text="Detailed product description"
    )
    
    # Price with decimal precision for currency
    price = models.DecimalField(
        max_digits=10,  # Up to 99,999,999.99
        decimal_places=2,
        validators=[MinValueValidator(Decimal('0.01'))],  # Minimum 1 cent
        help_text="Product price"
    )
    
    # Unique product identifier for inventory management
    sku = models.CharField(
        max_length=100,
        unique=True,  # FIXED: Keep unique for now, but monitor in production
        help_text="Stock Keeping Unit - unique product identifier"
    )
    
    # foreign key relationships
    category = models.ForeignKey(
        Category,
        on_delete=models.CASCADE,
        related_name='products', #category.products.all()
        help_text="product category"
    )
    seller = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='products', #access via user.products.all
        limit_choices_to={'role': 'SELLER'}, #only sellers can own products
        help_text="product seller"
    )
    
    # inventory management
    stock_quantity = models.PositiveIntegerField(
        default=0,
        help_text="current stock quantity"
    )
    # product flags
    is_active = models.BooleanField(
        default=True,
        help_text="Whether product is active and visible"
    )
    is_featured = models.BooleanField(
        default=False,
        help_text="Whether product is featured on homepage"
    )
    
    # analytics field,increments with each sale
    sales_count = models.PositiveIntegerField(
        default=0,
        help_text="total number of times this product has been sold"
    )
    
    # additional product attributes
    brand = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        help_text="Product brand"
    )
    
    tags = models.TextField(
        blank=True,
        null=True,
        help_text="Comma-separated tags for search and filtering"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'products'
        verbose_name = 'Product'
        verbose_name_plural = 'Products'
        ordering = ['-created_at']  #newest first
        # database indexes for performance
        indexes = [
            models.Index(fields=['category']),
            models.Index(fields=['seller']),
            models.Index(fields=['is_active']),
            models.Index(fields=['price']),
        ]
        
    def __str__(self):
        """String representation shows product name and seller"""
        return f"{self.name} by {self.seller.username}"
    
    @property
    def is_in_stock(self):
        """Check if product has stock available"""
        return self.stock_quantity > 0
    
    @property
    def is_low_stock(self, threshold=10):
        """Check if product is low on stock (default threshold: 10)"""
        return self.stock_quantity <= threshold

class ProductImage(models.Model):
    """
    product images,one product can have multiple images
    one image can be marked as primary
    """
    
    # foreign key to product
    product = models.ForeignKey(
        Product,
        on_delete=models.CASCADE,
        related_name='images',
        help_text="associated product"
    )
    
    # image stored on cloudinary
    image = CloudinaryField(
        'image',
        folder='ecommerce/products/',
        help_text="Product image"
    )
    
    # Alt text for accessibility and SEO
    alt_text = models.CharField(
        max_length=255,
        help_text="Alternative text for image accessibility"
    )
    
    # Mark one image as primary for product listings
    is_primary = models.BooleanField(
        default=False,
        help_text="Whether this is the primary product image"
    )
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'product_images'
        verbose_name = 'Product Image'
        verbose_name_plural = 'Product Images'
        ordering = ['-is_primary', 'created_at']
    
    def __str__(self):
        """String representation shows product name and primary status"""
        primary_text = " (Primary)" if self.is_primary else ""
        return f"Image for {self.product.name}{primary_text}"

class ProductSale(models.Model):
    """
    track individual product sales for analytics
    records who bought what,when and at what price
    """
    # foreign keys to product,seller,buyer
    product = models.ForeignKey(
        Product,
        on_delete=models.CASCADE,
        related_name='sales',
        help_text="Product that was sold"
    )
    
    seller = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='sales_as_seller',
        limit_choices_to={'role': 'SELLER'},
        help_text="Seller of the product"
    )
    
    buyer = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,  # Keep sale record even if buyer deleted
        null=True,
        blank=True,
        related_name='purchases',
        help_text="Buyer of the product (if registered user)"
    )
    
    # sale details
    quantity = models.PositiveIntegerField(
        default=1,
        help_text="quantity sold"
    )
    
    # price at time of sale since prices change
    price_at_sale = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text="price per unit at time of sale"
    )
    
    # when the sale occurred
    sale_date = models.DateTimeField(
        auto_now_add=True,
        help_text="date and time of sale"
    )
    
    class Meta:
        db_table = 'product_sales'
        verbose_name = 'Product Sale'
        verbose_name_plural = 'Product Sales'
        ordering = ['-sale_date']
        indexes = [
            models.Index(fields=['seller']),
            models.Index(fields=['product']),
            models.Index(fields=['sale_date']),
        ]
    
    def __str__(self):
        """String representation shows sale summary"""
        return f"{self.quantity}x {self.product.name} sold on {self.sale_date.date()}"
    
    @property
    def total_amount(self):
        """Calculate total sale amount"""
        return self.quantity * self.price_at_sale

class EmailLog(models.Model):
    """
    tracks all emails sent by the system
    records delivery status and error messages
    """
    # email types our system sends
    EMAIL_TYPE_CHOICES=[
        ('WELCOME', 'Welcome Email'),
        ('ANALYTICS_REPORT', 'Analytics Report'),
        ('LOW_STOCK_ALERT', 'Low Stock Alert'),
        ('SYSTEM_NOTIFICATION', 'System Notification'),
    ]
    # Email delivery status
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('SENT', 'Sent Successfully'),
        ('FAILED', 'Failed to Send'),
        ('BOUNCED', 'Bounced'),
    ]
    
    # Email details
    recipient_email = models.EmailField(
        help_text="Email address of recipient"
    )
    # Link to user if they're registered (for analytics)
    recipient_user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='received_emails',
        help_text="Recipient user,only if registered"
    )
    
    # Email categorization
    email_type = models.CharField(
        max_length=50,
        choices=EMAIL_TYPE_CHOICES,
        help_text="Type of email sent"
    )
    
    # Email content summary
    subject = models.CharField(
        max_length=255,
        help_text="Email subject line"
    )
    
    # Delivery tracking
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='PENDING',
        help_text="Email delivery status"
    )
    
    # Timestamp when email was sent
    sent_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When email was sent/attempted"
    )
    
    # Error message if sending failed
    error_message = models.TextField(
        blank=True,
        null=True,
        help_text="Error message if email failed to send"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        db_table = 'email_logs'
        verbose_name = 'Email Log'
        verbose_name_plural = 'Email Logs'
        ordering = ['-sent_at']
        # Indexes for analytics and filtering
        indexes = [
            models.Index(fields=['recipient_user']),
            models.Index(fields=['email_type']),
            models.Index(fields=['status']),
            models.Index(fields=['sent_at']),
        ]
    
    def __str__(self):
        """String representation shows email summary"""
        return f"{self.email_type} to {self.recipient_email} - {self.status}"